# Conditionals and IF Statements

In R, conditional statements or arguments are used to compare or analyse values/data based on certain conditions. In general, this is done with the use of 'relational operators' (`=`, `>`, `<`, `>=`, `<=`, `!=`) and 'logical operators' (OR, AND, AND/OR).

## Relational operators

The most basic of the 'relational operators' is the equality operator (`==`), which can be used to check if two objects (values, vectors, matrices etc.) are equal:

```{r}
4 == 3+1
5^2 == 25
8 %% 5 == 3  # The double percentage sign here resembles modulo arithmetic, i.e. 8 mod 5
```

This can also be performed on vectors on an element by element basis (as usual):

```{r}
1:10 == c(1,2,3,4,5,6,7,8,9,10)
1:10 == c(0,2,3,4,5,6,7,8,9,10)
```

Unsurprisingly, it also works on matrices on an element by element basis as well:

```{r}
matrix(5, nrow = 3, ncol = 3)
matrix(1:9, nrow = 3) == matrix(5, nrow = 3, ncol = 3)

diag(5, nrow = 3, ncol = 3)
diag(5, nrow = 3, ncol = 3) == 5 * diag(1, nrow =3)
```

Notice that this equality operator uses a double equal sign (`==`) rather than a single `=`. This is due to the fact the single equality sign is already used for assignments (similar to `<-`). This can be confusing, can easily cause errors and is the main reason I always suggest using `<-` for variable assignment.

Conversely, you can use the not equal operator (`!=`) in a similar way

```{r}
3 != 5
seq(1, 10, by = 1) != 1:10
```

**Note - In general, the (`!`) symbol negates any type of relational operator or Boolean value in R, e.g.**

```{r}
!TRUE
!FALSE
```

In a similar way, you should easily be able to understand how the rest of the relational operators work, i.e. (`<`, `>`, `<=`, `>=`). In the following example(s), I will introduce you to one of the many pre-programmed data sets that form part of the base package data sets, i.e, mtcars; we will discuss data sets in more details in the next few weeks.

```{r, eval = FALSE}
mtcars
```

```{r, echo = FALSE}
knitr::kable(mtcars)
```

:::{.exercise}
Assume we want to analyse the `hp` (horsepower) variable (column) only. Based on what we discussed last week regarding vector/matrix extraction, how can we extract the `hp` data only?
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- mtcars[,4] -->
<!-- ``` -->
<!-- </details> -->

An alternative method of extraction for data sets (data frames) is to use the `$` extraction command based on the column/variable name. Note that this only works on data frames and not general matrices, whereas the square bracket extraction works for both:

```{r}
(HP <- mtcars$hp)
HP > 200
```

What do you think will happen if we execute the code `sum(HP>200)` and `mean(HP>200)`? Have a think about this then check out the solution when you're ready.

<details>
<summary>**Solution**</summary>
```{r}
sum(HP > 200)
mean(HP > 200)
```
**In both of these case, the conditional statement(s) have produced a vector of `TRUE` and `FALSE` Boolean values. In R, these are understood as being values of 1 and 0 respectively. Hence, it is then possible to take the `sum()` or the `mean()` over the Boolean values themselves.** <br>
</details>

The above gives an examples of how R understands the Boolean values (`TRUE`/`FALSE`) as 1 and 0, respectively and also give you an idea of how powerful such simple lines of conditional code can be when used in the right way.

:::{.exercise}
Can you create a vector of all square numbers from 1 to 100 and count how many of these values are divisible by 3? Moreover, can you determine what percentage of them are NOT divisible by 5?
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- square.num <- (1:10)^2 -->
<!-- sum(square.num%%3) -->
<!-- mean(!square.num%%3) -->
<!-- ``` -->
<!-- </details> -->

In the next few weeks, we will look in more details at how we can use these relational operators (along with the logical operators discussed below) to conditionally extract data/values from a data.frame. This is a very helpful skill to learn for data handling and manipulation.

## Logical operators

'Logical operators' are used to check whether multiple conditions have been satisfied at the same time (AND) or at least one of them (OR). The key to understanding how these work in R, is understanding how logical operators work in theory.

Let us begin with the logical operator 'AND' which, in R, is denoted via `&` or `&&` (I will explain the difference later). For an AND statement/condition to evaluate to `TRUE`, both conditions in the statement must be `TRUE`. That is, the condition on the left is `TRUE` 'AND' the condition on the right is `TRUE`

```{r}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
```

```{r}
pi
pi > 3
pi < 4
pi > 3 & pi < 4
5 < 10 & 5 < 3
```

It is actually possible to have more than two arguments and include different relational operators as well.What do we think the following expression will evaluate to, `TRUE` or `FALSE`?

```{r}
pi > 0 & pi < 5 & !(pi %% 2 == 0)
```

As with relational operators, logical operators can also be used in vector form, where the & operator evaluates on a term by term basis, e.g.

```{r}
c(1,2,3) < c(2,3,4) & c(2,3,4) < c(3,4,5) # Think about this one a little!
```

In fact, this sort of logical/relational operation can also be computed on other objects than just numerical values, i.e. 'character strings':

```{r}
"Red" == "Red"
"Red" == "Blue"
"Red" == "red"

c(1, 2, 3) < c(2, 3, 4) & "Red" == "Blue" # How has this worked? The left hand side is a 3 element vector but the right is a single logical element?

c(1, 2, 3) < c(2, 1, 4) & "Red" == "Red"
```

In contrast to `&` which evaluates on a term by term basis, the double `&&` reads from left to right and only evaluates the first values of each vector

```{r}
c(1, 2, 3) < c(2, 1, 4) && "Red" == "Red"
c(5, 2, 3) < c(2, 1, 4) && "Red" == "Red"
```

The second logical operator is the so called OR operator, denoted by `|` and `||`, which evaluates to `TRUE` as long as 'at least one statement is `TRUE`', e.g.

```{r}
TRUE | TRUE
TRUE | FALSE
FALSE | TRUE
FALSE | FALSE

F | F | T | F #etc.
```

The same ideas as were discussed above for `&` work also for `|`, i.e. `|` evaluates element-wise, whilst `||` only evaluates the first element of a vector.

:::{.exercise}
With all this in mind, how can we calculate the number of cars in the mtcars data set that have horsepower greater than 200, mpg at most 30, are automatic but do not have 6 cylinders?
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- sum(mtcars$hp > 200 & mtcars$mpg <= 30 & mtcars$am == 0 & mtcars$cyl != 6) -->
<!-- ``` -->
<!-- </details> -->


:::{.exercise}
The set of data VADeaths contains the death rates (measured per 1000 population per year), in Virginia, USA, in 1940. The structure of this data set is a matrix (not a data frame) with the rows denoting age ranges and the columns sex/area.

i. How can we find out this information (and possibly more) about the data set? 
ii. Extract the two columns containing the female data, either together or separately.
iii. Using conditional arguments, determine how many age groups have a death rate larger than 20 for rural females and a death rate less than 30 from Urban females.
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- ?VADeaths -->
<!-- Female.data <- VADeaths[,c(2,4)] -->
<!-- Female.data[,1] > 20 & Female.data[,2] < 30 -->
<!-- sum(Female.data[,1] > 20 & Female.data[,2] < 30) -->
<!-- ``` -->
<!-- </details> -->

## IF statements

'IF' Statements are extremely popular and powerful tools in programming that are used to execute certain commands, based on given conditions. In most cases, the conditions used within IF statements are built up from combinations of the relational and logical operators seen above.

In general, an IF statement has the following form:


`if ( condition ){` <br>
  `command` <br>
`} else {` <br>
  `command` <br>
`}`

To see how an IF statement works in practice, let us look at a simple example to check if a number is odd or even

```{r}
x <- 8

if (x %% 2 == 0){
  print("This number is even")
} else {
  print("This number is odd")
}
```

You can actually make the output even better in this example by asking it to print out the value of $x$ that has been given  by using the paste function `paste()`. Notice the variable $x$ is not in quotation marks but the 'words' are.

```{r}
x <- 14

if (x %% 2 == 0){
  print(paste(x, "is an even number"))
} else {
  print(paste(x,"is an odd number"))
}
```

This is quite a simple example but it is very possible to have more complicated and longer IF statements that contain more conditional possibilities. If this is the case, you can simply extend the IF statement by adding `elseif` instead of just else. Finally, once you have finished with all conditions, you finish with else. For example

```{r}
x <- 7

if (x < 0) {
  print(paste(x, "is a negative number"))
} else if (x > 0) {
  print(paste(x, "is a positive number"))
} else {
  print(paste(x, "is Zero"))
}
```

:::{.exercise}
Can you create an IF statement which tells you whether a number (x) is divisible by another number (y), where both x and y can be changed (not fixed)? Hint: Use the modulus operator `%%`.
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- 6 -->
<!-- y <- 4 -->

<!-- if(x%%y==0){ -->
<!--   print(paste(x, "is divisible by", y)) -->
<!-- } else { -->
<!--   print(paste(x, "is NOT divisible by", y, "and has remainder", x%%y)) -->
<!-- } -->
<!-- ``` -->
<!-- </details> -->

Looking back at the previous two examples regarding even/odd and positive/negative numbers, we can actually combine these two statements by using logical operators within the IF conditions:

```{r}
x <- 4

if (x < 0 & x %% 2== 0) {
    print(paste(x, "is a negative even number"))
  } else if (x < 0) {
    print(paste(x,"is a negative odd number"))
} else if (x > 0 & x %% 2 == 0) {
    print(paste(x, "is a positive even number"))
  } else if (x > 0){
    print(paste(x, "is a positive odd number"))
} else {
  print(paste(x, "is Zero"))
}
```

In fact, you could do this an alternative way by 'nesting' IF statements inside one another to make several 'layers'. There is no right or wrong way to do these but through experience you will see either can be used depending on the situation.

```{r}
x <- 3

if (x < 0) {
  if (x %% 2 == 0){
  print(paste(x, "is a negative even number"))
  } else {
    print(paste(x,"is a negative odd number"))}
} else if (x > 0) {
  if (x %% 2 == 0){
  print(paste(x, "is a positive even number"))
  } else {
    print(paste(x, "is a positive odd number"))
  }
} else {
  print(paste(x, "is Zero"))
}
```

What happens if we let $x$ be a vector?

**Note - The IF statement will technically work in the sense it will print something out, but it will not do quite what we expect. This is because in an IF statement, the conditions or 'test statements' can only be single elements and thus, R will only consider the first element of the vector. With this in mind, it is important to note that if you use a logical operator  in an IF statement, it is always best to use the double version, i.e. `&&` or `||`.**

That being said, it is possible to bypass such a problem using the `ifelse()` function. The `ifelse()` function allows us to create an IF statement which only has one condition but can be applied to a vector element-wise.

```{r}
x <- c(1, 2, 3)
ifelse(x %% 2 == 0, "Even", "Odd")
```

**Note - This only works for quite simple statements.**

It is possible to use a more complicated IF statement on a vector as we tried above but to do so we have to introduce the idea of FOR loops, which we will discuss next week!

## Exercises

1. Create an R script that calculates the square root of a value, x. If the value contained in x is negative it should return `NA` as output.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- 4 # You can change this to any number you like. -->

<!-- if(x >= 0){ -->
<!--   sqrt(x) -->
<!-- } else { -->
<!--   NA -->
<!-- } -->
<!-- ``` -->
<!-- </details> -->

2. Create an R script that returns the maximum value out of the elements of a numeric vector of length 2 (two elements), without using the min, max or sort functions.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- c(3,5) # You can change these to any numbers you like. -->

<!-- if(x[2] >= x[1]){ -->
<!--   x[2] -->
<!-- } else { -->
<!--   x[1] -->
<!-- } -->
<!-- ``` -->
<!-- </details> -->

3. Use the command `x <- rexp(20, rate = 0.5)` to create a vector containing 20 simulations of an exponential random variable with mean 2. Return the number of values that are larger than the mean of the vector x. You are allowed to use the `mean()` function.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- rexp(20, rate = 0.5) -->
<!-- sum(x > mean(x)) -->
<!-- ``` -->
<!-- </details> -->

## Applied exercises

**Before proceeding with this exercise, you need to first generate 1,000 random values which will represent your data in throughout the questions. To do this, use the code `yearly.returns <- rbeta(1000, 5, 2) - 0.7`.**

The values you have generated represent 1000 yearly returns from an asset. Using this data:

1. Plot a histogram of the yearly returns for this asset. 

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- yearly.returns <- rbeta(1000, 5, 2) - 0.7 -->
<!-- hist(yearly.returns, breaks = 20) -->
<!-- ``` -->
<!-- </details> -->

2. Calculate the sample mean and sample standard deviation (s.d.) for the yearly returns. 

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- mean.return <- mean(yearly.returns) -->
<!-- total.dev <- sd(yearly.returns) -->
<!-- ``` -->
<!-- </details> -->

The Sharp Ratio is a measure of risk for a given asset calculated by comparing the mean returns to the risk-free rate of interest. That is, if we denote the mean return from an asset by $r_A$, the standard deviation by $\sigma_A$ and the risk-free rate of interest is denoted $r_f$, then the Sharpe ratio is given by $$SR = \frac{r_A-r_f}{\sigma_A}.$$

3. Given that the risk-free rate of interest is $r_f=4\%$, calculate the Sharpe Ratio for this asset. Comment on your result. 

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- risk.free <- 0.04 -->
<!-- Sharpe <- (mean.return-risk.free)/total.dev -->
<!-- ``` -->
<!-- </details> -->

4. Calculate the proportion of positive (gains) and negative (losses) yearly returns, respectively. 

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- gains.prop <- mean(yearly.returns > 0) -->
<!-- losses.prop <- mean(yearly.returns < 0) -->
<!-- ``` -->
<!-- </details> -->

5. Calculate the proportion of yearly returns that are larger than 2 s.d. away from the mean. 

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- prop.2.sd <- mean(yearly.returns < (mean.return-2*total.dev) | yearly.returns > (mean.return+2*total.dev)) -->
<!-- ``` -->
<!-- </details> -->

6. Calculate the mean yearly losses. **HINT: You can extract elements from vectors/matrices using boolean values, e.g. if `x` is a 2 element vector, then `x[c(TRUE, FALSE)]` will extract the first element but not the second.**

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- mean.loss <- mean(yearly.returns[yearly.returns < 0]) -->
<!-- ``` -->
<!-- </details> -->

7. Calculate the s.d. of the losses (downside risk) of the daily returns. Given your answer in part 2., comment on this result.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- sd.loss <- sd(yearly.returns[yearly.returns < 0]) -->
<!-- ``` -->
<!-- </details> -->

The Sortino Ratio is another measure of risk for an asset but only takes into account the downside risk of an investment. That is, if we denote the downside risk (deviation) by $\sigma_A^-$, then the Sortino ratio is given by $$SorR = \frac{r_A-r_f}{\sigma_A^-}.$$

8. Given that the risk-free rate of interest $r_f=4\%$, calculate the Sortino Ratio for this asset. Comment on the difference between this measure and the Sharpe Ratio. 

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- Sortino <- (mean.return-risk.free)/sd.loss -->
<!-- ``` -->
<!-- </details> -->

## DataCamp course(s)

- https://www.datacamp.com/courses/intermediate-r (Intermediate R Course)
- https://app.datacamp.com/learn/courses/intermediate-r-for-finance (Intermediate R for Finance Course)