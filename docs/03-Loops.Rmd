# Loops

## For loops

'For loops', sometimes just known as 'Loops' are one of the most useful tools in programming and you will find, once you understand how to implement them, that they become your best friends. That being said, it is very common that people like them so much that they are used when they are not necessary, as we will see later.

Simply put, a 'for loop' allows us to 'loop' through all the elements of a given object (usually a vector or matrix) and perform a command or operation for each element. When combined with 'IF statements', 'for loops' become very powerful and flexible and allow you to perform almost any task.

Let us start by understanding how a basic 'for loop' is constructed, then we will consider some simple examples. The general form of a for loop is as follows:

`for (i in x) {` <br>
`command in terms of i` <br>
`}` <br>

That is, i will take the first value of the object x, perform the command in the brackets with this given value of i, then i will loop to the second value of x and so on. For example:

```{r}
for (i in c(1,2,3,4,5)) {
  print(i^2)
}
```

This works perfectly but notice that we could also do this using what we called 'vectorised calculation', which takes advantage of how R deals with vectors on an element-by-element basis:

```{r}
(1:5)^2
```

As another example, consider the following:

```{r}
(x <- seq(from = 10, to = 100, by = 5))

for (i in x){
  print(i %% 2 == 0)
}
```

Again, was this necessary or could we have used vectorised calculations again? If possible, you should always use the vectorised calculation version of a command as this saves times and processing power. That being said,there are many situations where 'for loops' are necessary, not just useful.

Let us return to our mtcars data set seenin the previous chapter and consider a problem regarding plotting histograms of the data:

```{r}
hist(mtcars$hp)

hist(mtcars[,4])
```

Now, imagine you wanted a histogram for every variable. Executing the code `hist(mtcars)` wouldn't work as the input necessary for this function should be in the form of a single vector of values. However, to overcome this hurdle, we could make use of 'for loops':

```{r}
for (i in 1:ncol(mtcars)){
  hist(mtcars[,i], main = paste("Histogram of", colnames(mtcars)[i]))
}
```

The above is great, but it would be nice to have them all on one screen together. **Note that the code below is not really linked to for loops but is still worth mentioning here.**

```{r}
par(mfrow = c(3,4)) # Changes the plot frame to fit 3 rows and 4 columns of separate plots.
for(i in 1:ncol(mtcars)){
  hist(mtcars[,i])
}
```

This is much better but I would like the individual titles and axis labels to reflect the variable name:

```{r}
par(mfrow = c(3,4))
for(i in 1:ncol(mtcars)){
  hist(mtcars[,i], main = paste("Histogram of", colnames(mtcars)[i]), xlab = paste(colnames(mtcars)[i]))
}
```

Even this very simply example starts to show you the value and versatility of for loops.

Now, as mentioned above, it is also possible to combine 'for loops' with IF statements. For example, the code below counts the number of even numbers in a vector of values:

```{r}
x <- c(2,5,3,9,8,11,6)

count <- 0
for (i in x) {
  if(i %% 2 == 0){
    count <- count+1
  }
}
print(count)
```

:::{.exercise}
Is there a quicker and easier way to achieve what has been done above without 'for loops'?
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- sum(x %% 2 == 0) -->
<!-- ``` -->
<!-- </details> -->

:::{.exercise}
Can you write a 'for loop' that prints out the names of the cars in the `mtcars` data set which have 8 cylinders? Note, the car names can be found using the `rownames(mtcars)` command.
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- for(i in 1:nrow(mtcars)){ -->
<!--   if(mtcars$cyl[i]==8){ -->
<!--     print(rownames(mtcars)[i]) -->
<!--   } else {} -->
<!-- } -->
<!-- ``` -->
<!-- </details> -->

In fact, there is actually another way this can be done using conditional extraction which we will talk more about next week.

:::{.exercise}
Remember our IF statement from last week that didn't work correctly because we used a vector in the conditional statement? i.e.

```{r, eval=FALSE}
x <- c(1, 2, 3)

if (x < 0) {
  if (x %% 2 == 0){
    print(paste(x, "is a negative even number"))
  } else {
    print(paste(x,"is a negative odd number"))}
} else if (x > 0) {
  if (x %% 2 == 0){
    print(paste(x, "is a positive even number"))
  } else {
    print(paste(x, "is a positive odd number"))
  }
} else {
  print(paste(x, "is Zero"))
}
```
Can you now apply the idea of a 'for loop' to get this to work correctly?
:::

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- c(1, 2, 3) -->

<!-- for(i in x){ -->
<!-- if (i < 0) { -->
<!--   if (i %% 2 == 0){ -->
<!--     print(paste(i, "is a negative even number")) -->
<!--   } else { -->
<!--     print(paste(i,"is a negative odd number"))} -->
<!-- } else if (i > 0) { -->
<!--   if (i %% 2 == 0){ -->
<!--     print(paste(i, "is a positive even number")) -->
<!--   } else { -->
<!--     print(paste(i, "is a positive odd number")) -->
<!--   } -->
<!-- } else { -->
<!--   print(paste(i, "is Zero")) -->
<!--   } -->
<!-- } -->
<!-- ``` -->
<!-- </details> -->


### Matrices

So far, we have seen how we can Loop through a vector of values to perform certain tasks, but it is also possible to do this over a matrix of values. The only difference is that this requires two loops (one for each index - row and column). For example:

```{r}
(M <- matrix(round(runif(9,min = 0, max = 100)), nrow = 3, ncol = 3)) # This creates a 3x3 matrix of rounded uniform random values.

for(i in 1:nrow(M)){
  for(j in 1:ncol(M)){
    print(paste("Element [", i,",",j,"] of M is equal to",M[i,j]))
    }
}
```

Another very important technique that you will need when working with 'for loops' is how to store values in a new vector (matrix) as you finish each loop. This is something that you will use a lot when working through your R based assessments in your Actuarial modules, since you will be working  with larger data sets and need to make calculations which then need to be saved for use later on.

As a simple example let us see how we could use a 'for loop' to generate some random values and save them in a vector if they satisfy some condition.

Before we start, let us note how you can add a value to an already existing vector

```{r}
(x <- c(1, 3, 5, 7, 9))
(x <- c(x, 11))
```

In the above line of code, x has been over-written as the vector which contain all the values of the original vector x but then also includes 11 as well. This type of idea of over-writing a given value using itself has been seen already (count variable at the start of this session) and is a very common technique.

```{r}
vec <- c()
for (i in 1:20){
  rand <- rnorm(1, mean = 0, sd = 1) # This generates a standard normal random variable
  if(rand > 0){
    vec <- c(vec,rand)
  }
}
vec
```

Alternatively, you could actually save each value in the vector as a particular element, e.g.

```{r}
vec <- c()
vec
for (i in 1:20){
  rand <- rnorm(1, mean = 0, sd = 1)
  if(rand > 0){
    vec[i] <- rand
  }
}
vec
```

In fact, you could have easily set this up to store all the values in a Matrix rather than a vector

```{r}
(mat <- matrix(c(rep(NA, 16)), nrow = 4))

for (i in 1:4){
  for (j in 1:4){
  rand <- rnorm(1, mean = 0, sd = 1)
  if(rand > 0){
    mat[i,j] <- rand
  }
  }
}
mat
```

## While loops

The final tool we will consider in the area of loops, is the so-called 'WHILE loop'. A While loop is similar to a for loop but instead of simply looping through different values of a specified vector (i in 1:10) it will continue to loop whilst a certain condition holds and will only stop when this condition is no longer satisfied. For example:

```{r}
i <- 1
while (i < 6) {
  print(i)
  i <- i+1
}
```

**WARNING - Be very careful when using while loops. If you do not write them correctly they can result in your code running infinitely. As an example, try seeing what happens if you forget to increment i to add one each time.**

```{r, eval=FALSE}
i <- 1
while (i < 6) {
  print(i)
}
```

While loops are very helpful when the number of loops required is unknown. For example, imagine we wanted to find the smallest integer for which the sum of all positive integers up to this value was greater than 1000. This can easily be done using a while loop.

```{r}
i <- 1
sum <- 0

while(sum < 1000){
  sum <- sum + i
  if (sum < 1000){
  i <- i + 1
  } else {
    print(i)
  }
}

sum(1:44)
sum(1:45)
```

:::{.exercise}
Create a variable called `speed` and assign this a rounded random uniform distributed value between 50 - 60, i.e. `round(runif(1, 50, 60))`. Using a while loop, create a code that prints "Your speed is ?? - Slow Down" if speed is greater than 30 then takes 7 off the speed variable. If speed is less than or equal to 30 it should print out "Your speed is ?? - Thank you for not speeding".
:::

<!-- <details> -->
<!-- <summary>**Solutions**</summary> -->
<!-- ```{r} -->
<!-- speed <- round(runif(1, 50, 60)) -->
<!-- while(speed > 30){ -->
<!--   print(paste("Your speed is", speed, "- Slow Down!")) -->
<!--   speed <- speed - 7 -->
<!-- } -->
<!-- print(paste("Your speed is", speed, "- Thank you for not speeding.")) -->
<!-- ``` -->
<!-- </details> -->

I appreciate this is a lot to take in for those who are not familiar with programming but I assure these ideas become second nature with a little practice. We will use them in a larger exercise in the last session so you can see how and when these things would all be used in a practical example. However, for now, I highly recommend that you complete the exercises in DataCamp on conditional statements and loops (Intermediate R) for extra practice.

There are other versions and common commands used in loops, namely `break`, `next` and `repeats`, but I will leave these for you to explore in your own time (ideally via DataCamp). You will need these for the exercises below.

## Exercises

1. Use the command `x <- rexp(20, rate = 0.5)` to create a vector containing 20 simulations of an Exponential random variable with mean $2$. Using a loop, return the number of values that are larger than the sample mean of the vector x. You are allowed to use the `mean()` function.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- rexp(20, rate = 0.5) -->
<!-- num <- 0 -->
<!-- for(i in 1:length(x)){ -->
<!--  if(x[i] > mean(x)){ -->
<!--    num <- num + 1 -->
<!--  } -->
<!-- } -->
<!-- x -->
<!-- ``` -->
<!-- </details> -->

2. Write a `while()` loop which prints out the odd numbers from 1 through 7.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- i <- 1 -->
<!-- while(i <= 7){ -->
<!--   ifelse(i %% 2 == 1, print(i), NA) -->
<!--   i <- i + 1 -->
<!-- } -->
<!-- ``` -->
<!-- </details> -->

3. Using `for()` loops, generate and print the first 20 values of the famous Fibonacci sequence (starting with $0, 1$). Recall, the Fibonacci sequence is obtained by evaluating the next number in the sequence as the sum of the previous two numbers in the sequence.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- Fib <- c(0,1) -->
<!-- for (i in 3:20){ -->
<!--   Fib[i] <- Fib[i-1] + Fib[i-2] -->
<!-- } -->
<!-- Fib -->
<!-- ``` -->
<!-- </details> -->

4. By altering your code in the previous question, use a `while()` loop to determine how many values the Fibonacci sequence contains before its value exceeds 100,000.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- Fib1 <- c(0,1) -->
<!-- i <- 2 -->
<!-- while(Fib1[i] < 100000){ -->
<!--   Fib1[i+1] <- Fib1[i] + Fib1[i-1] -->
<!--   i <- i + 1 -->
<!-- } -->
<!-- length(Fib1) -->
<!-- ``` -->
<!-- </details> -->

5. Use a `while()` loop to determine the smallest value of $x$ such that
\begin{equation*}
\prod_{n=1}^x n > 10^{6}.
\end{equation*}

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- prod <- 1 -->
<!-- n <- 1 -->
<!-- while(prod <= 1000000){ -->
<!--   n <- n + 1 -->
<!--   prod <- prod*n -->
<!-- } -->
<!-- n -->
<!-- ``` -->
<!-- </details> -->

6. Using a `for()` loop, simulate the flip of a fair coin twenty times, keeping track of the individual outcomes (1 = Heads, 0 = Tails) in a vector.

**[Hint: You can simulate random numbers that follow given distributions. For example, normal random numbers using rnorm(), exponential using rexp() as seen in Problem 1 or binomial random values using rbinom(). Moreover, the Bernoulli distribution with success parameter $p \in [0,1]$, which gives a value of 0 or 1, is nothing but a binomial distribution with parameters $n =1$ and $p$.]**

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- rbinom(20, 1, 0.5) -->
<!-- Flips <- c() -->
<!-- for(i in 1:length(x)){ -->
<!--   Flips[i] <- ifelse(x[i] == 1, "Heads", "Tails") -->
<!-- } -->
<!-- Flips -->
<!-- ``` -->
<!-- </details> -->

7. Can you solve the previous problem again without the use of `for()` loops?

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- x <- rbinom(20, 1, 0.5) -->
<!-- ifelse(x == 1, "Heads", "Tails") -->
<!-- ``` -->
<!-- </details> -->

8. Using `for()` loops, fill a $5 \times 5$ matrix with simulated values from the Poisson distribution having parameter $\lambda = 5$ (`rpois(n, lambda = 5)`). Do this again but without using loops, only 'vectorised calculations'.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- # With Loops: -->
<!-- M <- matrix(NA, nrow = 5, ncol = 5) -->
<!-- for(i in 1:5){ -->
<!--   for(j in 1:5){ -->
<!--     x <- rpois(1, lambda = 5) -->
<!--     M[i,j] <- x -->
<!--   } -->
<!-- } -->
<!-- M -->

<!-- # Vectorised calculation: -->
<!-- x <- rpois(25, lambda = 5) -->
<!-- (M1 <- matrix(x, nrow = 5, ncol = 5)) -->
<!-- ``` -->
<!-- </details> -->

**Advanced Extension:** Can you modify the above to only fill the matrix with simulated values between 1 and 8? Hint: You will have to use the `repeat` and `break` commands.

<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- sim <- c() -->
<!-- for(i in 1:25){ -->
<!--   repeat{ -->
<!--     x <- rpois(1, lambda = 5) -->
<!--     if(x >= 1 && x <= 8){ -->
<!--       sim[i] <- x -->
<!--       break -->
<!--     } else {} -->
<!--   } -->
<!-- } -->
<!-- matrix(sim, nrow = 5, ncol = 5) -->
<!-- ``` -->
<!-- </details> -->

## Applied Exercises 

**The problems below are a little more involved and may take some time. Please have a go at these but do not worry if you find this difficult, we will actually see something similar to this again next semester.**

1. Assume that the daily returns on an asset are normally distributed with mean 0 and standard deviation of 0.01. Assuming that the starting price is £100, write a `while()` loop to simulate the daily stock price of this asset until the moment it exceeds £150 or falls below £50. 

**[Recall: You can simulate a normal random value using the following command `rnorm(n, mean = , sd = )` where $n$ is the number of values you want to simulate]**

2. How many days does it take for the stock price to exceed £150 or drop below £50? 

3. Plot the path of the stock price over time using the `plot()` function.

4. Using a `for()` loop, repeat the first step 100 times and provide an estimate for the number of days it will take to exceed £150 or drop below £50.

5. Simulate the stock price for exactly 365 days. If the price exceeds £150 or falls below £50, stop the simulation and ask R to print out the value of the stock at this point.

6. By repeating a similar idea to the previous step 100 times, can you estimate the probability that the stock price will either exceed £150 or drop below £50. 



<!-- <details> -->
<!-- <summary>**Solution**</summary> -->
<!-- ```{r} -->
<!-- stock <- 100 -->
<!-- stock.prices <- c(stock) -->
<!-- i <- 1 -->
<!-- while(stock >= 50 && stock <= 150){ -->
<!--   i <- i + 1 -->
<!--   return <- rnorm(1, 0, 0.01) -->
<!--   stock <- stock*(1 + return) -->
<!--   stock.prices <- c(stock.prices, stock) -->
<!-- } -->
<!-- i -->

<!-- plot(1:i, stock.prices, type = "l", main = "Stock Price Over Time", xlab = "Time (Days)", ylab = "Stock Price (£)", ylim = c(40, 160)) -->
<!-- abline(h = 50, lty = 2, col = "red") -->
<!-- abline(h = 150, lty = 2, col = "red") -->

<!-- ``` -->
<!-- </details> -->

## DataCamp course(s)

- https://www.datacamp.com/courses/intermediate-r (Intermediate R Course)
- https://app.datacamp.com/learn/courses/intermediate-r-for-finance (Intermidiate R for Finance Course)
